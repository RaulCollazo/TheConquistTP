Object subclass: #Casilla	instanceVariableNames: 'morph color tema filaCasilla columnaCasilla labelMorph punteroJuego'	classVariableNames: ''	package: 'TheConquist'!!Casilla methodsFor: 'accessing' stamp: '1/24/2025 14:47'!morph	^ morph! !!Casilla methodsFor: 'accessing' stamp: '1/24/2025 14:47'!morph: anObject	morph := anObject! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 19:52'!color	^ color! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 19:52'!color: anObject	color := anObject! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 19:52'!tema	^ tema! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 19:52'!tema: anObject	tema := anObject! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 22:04'!filaCasilla	^ filaCasilla! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 22:04'!filaCasilla: anObject	filaCasilla := anObject! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 22:04'!columnaCasilla	^ columnaCasilla! !!Casilla methodsFor: 'accessing' stamp: '2/8/2025 22:04'!columnaCasilla: anObject	columnaCasilla := anObject! !!Casilla methodsFor: 'accessing' stamp: '2/9/2025 03:59'!labelMorph	^ labelMorph! !!Casilla methodsFor: 'accessing' stamp: '2/9/2025 03:59'!labelMorph: anObject	labelMorph := anObject! !!Casilla methodsFor: 'accessing' stamp: '2/16/2025 20:36'!punteroJuego: unJuego	punteroJuego:= unJuego.! !!Casilla methodsFor: 'accessing' stamp: '2/16/2025 20:36'!punteroJuego! !!Casilla methodsFor: 'Crear Casillas y funciones de' stamp: '2/9/2025 03:59'!crearCasilla: x and: y label: label|buttonMorph|labelMorph:= label.filaCasilla:=x. columnaCasilla := y.buttonMorph := Morph new.buttonMorph bounds: (25@25 extent: 125@125).buttonMorph color: Color random.buttonMorph borderWidth: 2.buttonMorph borderColor: Color black.buttonMorph on: #mouseUp send: #botonClickeado to: self.labelMorph := StringMorph new.labelMorph contents: label.self tema: label.labelMorph position: (buttonMorph bounds center - (labelMorph extent / 2))."Agregar la etiqueta al botón"buttonMorph addMorph: labelMorph.self morph: buttonMorph.self morph: buttonMorph.! !!Casilla methodsFor: 'Crear Casillas y funciones de' stamp: '2/16/2025 21:23'!botonClickeadoself respuestaClick:( punteroJuego jugadaVálida: (punteroJuego cantJugadores) nombreJugador: (punteroJuego jugadorActual ) labelMorph: self)! !!Casilla methodsFor: 'Crear Casillas y funciones de' stamp: '2/16/2025 20:41'!respuestaClick: argumentoargumento ifTrue:[self sosElMismo: self] ifFalse: [ UIManager default inform: 'Movimiento no válido' ].! !!Casilla methodsFor: 'Crear Casillas y funciones de' stamp: '2/16/2025 23:49'!sosElMismo: casillalocal|duelo|(casillalocal tema) = (punteroJuego jugadorActual tema) ifTrue: [UIManager default inform: 'No puedes desafiarte a ti mismo...'] ifFalse: [ UIManager default inform:'Inicio de duelo'.	duelo:= DueloMC new.	duelo iniciarDueloEnJuego: punteroJuego conTema: self tema.	]! !Object subclass: #Juego	instanceVariableNames: 'cantJugadores imagenMorph turnoActual jugadorActual juegoActivo tableroLogico tableroMorph infoBasicaMorph dosJugadores'	classVariableNames: ''	package: 'TheConquist'!!Juego methodsFor: 'accessing' stamp: '2/16/2025 20:17'!cantJugadores	^ cantJugadores! !!Juego methodsFor: 'accessing' stamp: '2/16/2025 20:17'!cantJugadores: anObject	cantJugadores := anObject! !!Juego methodsFor: 'accessing' stamp: '1/21/2025 21:41'!imagenMorph	^ imagenMorph! !!Juego methodsFor: 'accessing' stamp: '1/21/2025 21:41'!imagenMorph: anObject	imagenMorph := anObject! !!Juego methodsFor: 'accessing' stamp: '2/7/2025 14:17'!turnoActual ^turnoActual.! !!Juego methodsFor: 'accessing' stamp: '2/7/2025 14:15'!turnoActual: anObject	turnoActual := anObject! !!Juego methodsFor: 'accessing' stamp: '2/7/2025 15:29'!jugadorActual	^ jugadorActual! !!Juego methodsFor: 'accessing' stamp: '2/7/2025 15:29'!jugadorActual: anObject	jugadorActual := anObject! !!Juego methodsFor: 'accessing' stamp: '2/13/2025 22:50'!juegoActivo	^ juegoActivo! !!Juego methodsFor: 'accessing' stamp: '2/13/2025 23:03'!juegoActivo: anObject	juegoActivo := anObject! !!Juego methodsFor: 'accessing' stamp: '2/16/2025 20:19'!tableroLogico: argumento	tableroLogico:= argumento.! !!Juego methodsFor: 'accessing' stamp: '2/16/2025 20:19'!tableroLogico	^tableroLogico! !!Juego methodsFor: 'accessing' stamp: '2/16/2025 22:57'!tableroMorph	^tableroMorph.! !!Juego methodsFor: 'accessing' stamp: '2/16/2025 22:57'!tableroMorph:unMorph	tableroMorph:=unMorph.! !!Juego methodsFor: 'initialization' stamp: '2/16/2025 22:46'!initializeturnoActual := 0.juegoActivo := 0.! !!Juego methodsFor: 'ManageJuego' stamp: '1/23/2025 16:32'!borrarVentanasLabeledParticular SystemWindow allInstances do: [ :each |         (each label = 'TheConquist') ifTrue: [            each close. "Cierra la ventana"        ].    ].! !!Juego methodsFor: 'ManageJuego'!dibujarFondo	| tmp1 tmp2 tmp3 tmp4 tmp6 |	tmp1 := Form fromFileNamed:		        FileSystem workingDirectory		        / 'assets/backgrounds/background.png'.	imagenMorph := ImageMorph new.	imagenMorph		image: tmp1;		position: 0 @ 0.	tmp2 := SimpleButtonMorph new.	tmp2		label: 'Nuevo Juego';		target: self;		actionSelector: #obtenerCantJugadores;		extent: 150 @ 50;		position: imagenMorph width // 2 - (tmp2 width // 2)			@ (imagenMorph height // 2 - (tmp2 height // 2) + 120).	tmp3 := SimpleButtonMorph new.	tmp3		label: 'Salir';		target: self;		actionSelector: #borrarVentanasLabeledParticular;		extent: 120 @ 50;		position: imagenMorph width // 2 - (tmp3 width // 2)			@ (imagenMorph height // 2 - (tmp3 height // 2) + 220).	imagenMorph		addMorph: tmp2;		addMorph: tmp3.	tmp4 := imagenMorph openInWindowLabeled: 'TheConquist'.	[	tmp4 position: 0 @ 0.	tmp6 := World extent.	tmp4		extent: tmp6;		borderWidth: 0 ] ensure: [ tmp4 show ]! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 22:59'!dibujarFondoTablero	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |	tmp1 := Form fromFileNamed: FileSystem workingDirectory		        / 'assets/backgrounds/background-table.jpg'.	tmp2 := ImageMorph new.	tmp2		image: tmp1;		position: 0 @ 0.	tmp3 := ScrollPane new.	tmp3 scroller addMorph: tmp2.	tmp3 extent: 300 @ 300.	self tableroLogico		dibujarTablero: tmp2		cantNPC: self cantJugadores.	tmp4 := SystemWindow allInstances		        detect: [ :arg1 | arg1 label = 'TheConquist' ]		        ifNone: [  ].	tmp4 ifNotNil: [ tmp4 close ].	tmp6 := World extent.	tmp5 := tmp3 openInWindowLabeled: 'TheConquist Board'.	[	tmp5		position: 0 @ 0;		extent: tmp6;		borderWidth: 0 ] ensure: [ tmp5 show ].	self tableroMorph: tmp2.! !!Juego methodsFor: 'ManageJuego' stamp: '1/22/2025 05:28'!eliminarMorphsWorld submorphs "Selecciona a todos los submorphs y descide si es un ImageMorph para eliminarlo"        select: [ :morph | morph isKindOf: ImageMorph ]        thenDo: [ :morph | morph delete ].! !!Juego methodsFor: 'ManageJuego' stamp: '1/21/2025 22:43'!nuevoJuegoTranscript show: ['Nuevo juego'].! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 22:34'!obtenerCantJugadores    | flag matrizTemas tablero|    flag := false.    "Solicitar la cantidad de NPCs"    [ flag not ] whileTrue: [        self cantJugadores: (UIManager default request: '¿Cuántos participantes hay?') asNumber.        ((self cantJugadores sqrt isInteger))             ifTrue: [ flag := true ]            ifFalse: [ UIManager default inform: 'Valor inválido' ].    ]."    Solicitar la cantidad de jugadores humanos    CantJugadores := (UIManager default request: '¿Cuántos participantes humanos habrá?') asNumber."tablero:= TableroLogico new.self tableroLogico: tablero.matrizTemas := tableroLogico crearMatrizTemas: self cantJugadores.self tableroLogico crearMatrizTablero: self cantJugadores.self tableroLogico crearMatrizMorphs: cantJugadores enJuego: self.self dibujarFondoTablero.self flujoPrincipalTableroYaCreado.! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 22:59'!flujoPrincipalTableroYaCreado		(UIManager default confirm: 'Turno Actual: ', (self turnoActual) asString ) ifTrue:[			turnoActual := turnoActual  + 1 .			self turnoActualmente.			self obtenerJugadorActual.			self dibujarInfoBasica:self tableroMorph cantJugadores: self cantJugadores.]! !!Juego methodsFor: 'ManageJuego' stamp: '2/17/2025 15:58'!ganaDesafiante: arg1 desafiado: arg2	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 fila columna |	tmp4 := self cantJugadores sqrt ceiling.	tmp5 := self cantJugadores sqrt ceiling.	tmp1 := 1.	tmp2 := 1.	tmp3 := nil.	tmp6 := self cantJugadores.	tmp7 := tmp6.	tmp8 := tmp7.	1 to: tmp8 do: [ :tmp9 |		(TableroLogico matrizDeMorphs at: tmp1 column: tmp2) tema		= arg1 tema ifTrue: [			tmp3 := TableroLogico matrizDeMorphs at: tmp1 column: tmp2 ].		tmp1 := tmp1 + 1.		tmp1 > tmp4 ifTrue: [			tmp1 := 1.			tmp2 := tmp2 + 1 ] ].	1.	tmp1 := 1.	tmp2 := 1.	tmp6 := self cantJugadores.	tmp7 := tmp6.	tmp8 := tmp7.	1 to: tmp8 do: [ :tmp9 |		tmp1 > tmp4 ifTrue: [			tmp1 := 1.			tmp2 := tmp2 + 1 ].		(self tableroLogico matrizDeTemas at: tmp1 column: tmp2) = arg2 tema			ifTrue: [				self tableroLogico matrizDeTemas at: tmp1 column: tmp2 put: arg1 tema.				(self tableroLogico matrizDeMorphs at: tmp1 column: tmp2) tema				= arg2 tema ifTrue: [					(self tableroLogico matrizDeMorphs at: tmp1 column: tmp2) tema:						arg1 tema.					(self tableroLogico matrizDeMorphs at: tmp1 column: tmp2) morph						color: tmp3 morph color.					(self tableroLogico matrizDeMorphs at: tmp1 column: tmp2) labelMorph						contents: arg1 tema ] ].		tmp1 := tmp1 + 1.		tmp1 > tmp4 ifTrue: [			tmp1 := 1.			tmp2 := tmp2 + 1 ] ].	1.	UIManager default inform:		'Ganó: ' , arg1 nombre , ' ' , 'tema: ' , arg1 tema.	fila := 1.	columna := 1.	1 to: cantJugadores do: [ :i |		(fila > self cantJugadores sqrt ceiling) ifTrue: [ fila := 1. columna := columna + 1 ].		((self tableroLogico matrizTableroLógico at: fila column: columna) nombre = arg2 nombre) ifTrue: [			self tableroLogico matrizTableroLógico at: fila column: columna put: arg1		].		fila := fila + 1.	].! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 09:48'!simularDuelo	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp10 tmp12 tmp13 tmp15 |	tmp1 := OrderedCollection new.	tmp2 := self cantNPC sqrt ceiling.	tmp3 := self cantNPC sqrt ceiling.	tmp4 := self cantNPC.	tmp5 := tmp4.	tmp6 := OrderedCollection new.	tmp10 := tmp5.	1 to: tmp10 do: [ :tmp11 |		tmp12 := tmp11 - 1 // tmp3 + 1.		tmp13 := tmp11 - 1 \\ tmp3 + 1.		(TableroLogico matrizDeTemas at: tmp12 column: tmp13)		= jugadorActual tema ifTrue: [			tmp12 > 1 ifTrue: [ tmp6 add: tmp12 - 1 @ tmp13 ].			tmp12 < tmp2 ifTrue: [ tmp6 add: tmp12 + 1 @ tmp13 ].			tmp13 > 1 ifTrue: [ tmp6 add: tmp12 @ (tmp13 - 1) ].			tmp13 < tmp3 ifTrue: [ tmp6 add: tmp12 @ (tmp13 + 1) ] ] ].	1.	tmp6 do: [ :arg1 |		tmp12 := arg1 x.		tmp13 := arg1 y.		(TableroLogico matrizDeTemas at: tmp12 column: tmp13)		~= jugadorActual tema ifTrue: [ tmp1 add: tmp12 @ tmp13 ] ].	tmp15 := tmp1 atRandom.	tmp8 := tmp15		        ifNil: [ ^ self flujoPrincipalTableroYaCreado ]		        ifNotNil: [ tmp15 ].	[	tmp7 := TableroLogico matrizTableroLógico at: tmp8 x column: tmp8 y.	tmp7 tema = jugadorActual tema and: [ tmp1 size > 1 ] ] whileTrue: [		| tmp17 |		tmp1 remove: tmp8.		tmp17 := tmp1 atRandom.		tmp8 := tmp17			        ifNil: [ ^ self flujoPrincipalTableroYaCreado ]			        ifNotNil: [ tmp17 ] ].	tmp12 := tmp8 x.	tmp13 := tmp8 y.	tmp7 := TableroLogico matrizTableroLógico at: tmp12 column: tmp13.	tmp7 nPC		ifTrue: [			Transcript show: 'Duelo de bot - bot'.			Random new next < 0.5				ifTrue: [ self ganaDesafiante: jugadorActual desafiado: tmp7 ]				ifFalse: [ self ganaDesafiante: tmp7 desafiado: jugadorActual ] ]		ifFalse: [ Duelo dueloBotNPC: jugadorActual desafiado:tmp7 ].	self flujoPrincipalTableroYaCreado! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 08:06'!jugadorPersonaActiva"UIManager default confirm: 'Hola'."! !!Juego methodsFor: 'ManageJuego' stamp: '2/17/2025 15:31'!flujoPrincipalPostDuelo		(UIManager default confirm: 'Turno Actual: ', (self turnoActual) asString ) ifTrue:[			turnoActual := turnoActual  + 1 .			self turnoActualmente.			self obtenerJugadorActual.			self actualizarInfoBasica.			(turnoActual = 10) ifTrue: [				|duelo tema|				tema:= self determinarDosJugadores.				duelo:= DueloMC new.				duelo iniciarDueloDeluxeEnJuego: self conTema: tema.]].! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 23:09'!actualizarInfoBasica	|jugAct turnoAct|		jugAct:= self jugadorActual.	turnoAct:= self turnoActual.		((self infoBasicaMorph)at:1)contents: ('Jugador Actual: ', (self jugadorActual)nombre , ' Tema: ',(self jugadorActual)tema).	((self infoBasicaMorph)at:2)contents: ('Turno Actual: ', (self turnoActual)asString).! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 23:02'!infoBasicaMorph	^infoBasicaMorph.	! !!Juego methodsFor: 'ManageJuego' stamp: '2/16/2025 23:02'!infoBasicaMorph:unMorph	infoBasicaMorph:=unMorph.	! !!Juego methodsFor: 'removing' stamp: '2/9/2025 03:14'!removeButtonMorphs    "Elimina todos los ButtonMorphs de la variable de instancia imagenMorph"    imagenMorph := nil.! !!Juego methodsFor: 'removing' stamp: '2/9/2025 03:43'!removeAllMorphsFromImageMorphExceptBackground    "Elimina todos los morphs añadidos a imagenMorph excepto el background"    imagenMorph submorphs do: [:each |         (each isKindOf: ImageMorph) ifFalse: [ imagenMorph removeMorph: each ]    ].! !!Juego methodsFor: 'Accesorios' stamp: '2/14/2025 00:53'!esJugadorBot(self jugadorActual nPC) ifTrue: [ self simularDuelo ] ifFalse: [self jugadorPersonaActiva.].! !!Juego methodsFor: 'Accesorios' stamp: '2/16/2025 20:29'!obtenerJugadorActualself jugadorActual: (tableroLogico obtenerJugadorTurnoActual: self cantJugadores).self class jugadordelTurnoActualClase: self jugadorActual.UIManager default inform: (('Jugador actual: '),  jugadorActual nombre,' ', 'Tema: ', jugadorActual tema).! !!Juego methodsFor: 'Accesorios' stamp: '2/17/2025 15:18'!turnoActualmente(self turnoActual = 0 ) ifTrue: [ UIManager default inform: 'Primer Turno...Buscando primer Jugador' ] ifFalse: [ UIManager default inform: ('Turno número: ', (self turnoActual asString)). ]! !!Juego methodsFor: 'as yet unclassified' stamp: '2/14/2025 02:29'!verificarContinuidad    | fila columna primer nombreDiferente encontrado |    primer := (TableroLogico matrizTableroLógico at: self cantNPC sqrt ceiling column: self cantNPC sqrt ceiling) nombre.    fila := 1.    columna := 1.    encontrado := false.    1 to: self cantNPC do: [ :i |        (fila > self cantNPC sqrt ceiling) ifTrue: [             fila := 1.             columna := columna + 1.        ].                nombreDiferente := (TableroLogico matrizTableroLógico at: fila column: columna) nombre.                (nombreDiferente ~= primer) ifTrue: [             encontrado := true.        ].        fila := fila + 1.    ].    ^ encontrado. "Retorna true si encontró al menos un nombre diferente, de lo contrario false"! !!Juego methodsFor: 'as yet unclassified' stamp: '2/16/2025 21:26'!jugadaVálida: cantNPC nombreJugador: nombreJugador labelMorph: casilla    | fila columna listaDeFilasValidas listatema maxFila maxColumna |    listaDeFilasValidas := OrderedCollection new.    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.    1 to: cantNPC do: [ :i |        fila := (i - 1) // maxColumna + 1.        columna := (i - 1) \\ maxColumna + 1.        "Verifica si el tema del jugador coincide en la posición actual"        ((self tableroLogico matrizDeTemas at: fila column: columna) = nombreJugador tema ) ifTrue: [            "Agrega las posiciones válidas en base a la posición actual"            (fila = 1 and: columna = 1) ifTrue: [                listaDeFilasValidas add: 2@1.                listaDeFilasValidas add: 1@2.            ].            (fila = 1 and: columna = maxColumna) ifTrue: [                listaDeFilasValidas add: 1@(maxColumna - 1).                listaDeFilasValidas add: 2@maxColumna.            ].            (fila = maxFila and: columna = 1) ifTrue: [                listaDeFilasValidas add: (maxFila - 1)@1.                listaDeFilasValidas add: maxFila@2.            ].            (fila = maxFila and: columna = maxColumna) ifTrue: [                listaDeFilasValidas add: maxFila@(maxColumna - 1).                listaDeFilasValidas add: (maxFila - 1)@maxColumna.            ].            (fila = 1 and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: 1@(columna - 1).                listaDeFilasValidas add: 1@(columna + 1).                listaDeFilasValidas add: 2@columna.            ].            (fila = maxFila and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: maxFila@(columna - 1).                listaDeFilasValidas add: maxFila@(columna + 1).                listaDeFilasValidas add: (maxFila - 1)@columna.            ].            (columna = 1 and: (1 < fila and: fila < maxFila)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@1.                listaDeFilasValidas add: (fila + 1)@1.                listaDeFilasValidas add: fila@2.            ].            (columna = maxColumna and: (1 < fila and: fila < maxFila)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@maxColumna.                listaDeFilasValidas add: (fila + 1)@maxColumna.                listaDeFilasValidas add: fila@(maxColumna - 1).            ].            ((1 < fila and: fila < maxFila) and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@columna.                listaDeFilasValidas add: (fila + 1)@columna.                listaDeFilasValidas add: fila@(columna - 1).                listaDeFilasValidas add: fila@(columna + 1).            ].        ].    ].    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.(listaDeFilasValidas includes: ((casilla filaCasilla)@(casilla columnaCasilla)) )ifTrue: [^true] ifFalse: [ ^false].! !!Juego methodsFor: 'as yet unclassified' stamp: '2/17/2025 17:40'!dibujarInfoBasica: imgMorph cantJugadores: cantJug| contenedor stringMorph1 stringMorph2 botonPablo labelMorph cant aux|cant := cantJug sqrt ceiling."Crear el contenedor principal"contenedor := Morph new    color: Color black;    bounds: (25@25 extent: 700@70);    position: (0@(cant*120)+10);    borderWidth: 2;    borderColor: Color white;    layoutPolicy: ProportionalLayout new; "Establecer layout para que use LayoutFrame"    yourself."Crear los StringMorphs"stringMorph1 := StringMorph new    contents: ('Jugador Actual: ', (self jugadorActual)nombre , ' Tema: ',(self jugadorActual)tema);    color: Color white;     layoutFrame: (LayoutFrame new        leftFraction: 0.0;        rightFraction: 0.33;        topFraction: 0.0;        bottomFraction: 1.0);    yourself.stringMorph2 := StringMorph new    contents: ('Turno Actual: ', (self turnoActual)asString);    color: Color white;    layoutFrame: (LayoutFrame new        leftFraction: 0.33;        rightFraction: 1.0;        topFraction: 0.0;        bottomFraction: 1.0);    yourself.	labelMorph:= 'Pasar turno'.	botonPablo := Morph new.	botonPablo bounds: (25@25 extent: 134@40);		color: Color gray;		borderWidth: 2;		borderColor: Color black;		on: #mouseUp send:#flujoPrincipalPostDuelo to:self;		layoutFrame: (LayoutFrame new        leftFraction: 0.33;        rightFraction: 1.0;        topFraction: 0.0;        bottomFraction: 1.0);		yourself.	"Añadir los StringMorphs al contenedor"	contenedor addMorph: stringMorph1.	contenedor addMorph: stringMorph2.	contenedor addMorph: botonPablo.	"Mostrar el contenedor"	imgMorph addMorph: contenedor.	aux:= Array new:2.	aux at:1 put:stringMorph1.	aux at:2 put:stringMorph2.		self infoBasicaMorph: aux.! !!Juego methodsFor: 'as yet unclassified' stamp: '2/17/2025 15:31'!determinarDosJugadores	|jugador1 fila columna MAX jugador2 cant|	fila := 1.	columna := 1.	MAX:= 0.	cant:= self cantJugadores.   1 to: cant do: [ :index |	|jugadorIteracion|        "Iteramos sobre la matriz TableroLogico"        (fila > cant sqrt ceiling) ifTrue: [             fila := 1.             columna := columna + 1         ].		jugadorIteracion:= (self tableroLogico matrizTableroLógico)at:fila column:columna. 		jugadorIteracion puntosProbabilidad <= MAX ifTrue: [			MAX:=jugadorIteracion puntosProbabilidad.			jugador1:= jugadorIteracion].			fila := fila + 1.			].		MAX:= 0.fila := 1.columna := 1.   1 to: cant do: [ :index |		|jugadorIteracion|		"Iteramos sobre la matriz TableroLogico"		(fila > cant sqrt ceiling) ifTrue: [             fila := 1.             columna := columna + 1         ].		jugadorIteracion:= (self tableroLogico matrizTableroLógico)at:fila column:columna.				jugadorIteracion puntosProbabilidad <= MAX ifTrue: [			jugadorIteracion = jugador1 ifFalse:[				MAX:=jugadorIteracion puntosProbabilidad.				jugador2:= jugadorIteracion        ].		].        fila := fila + 1.    ].	self jugadorActual: jugador1.	^jugador2 tema.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Juego class	instanceVariableNames: 'desafiante desafiado cantNPCClase jugadordelTurnoActualClase instancia'!!Juego class methodsFor: 'as yet unclassified' stamp: '2/15/2025 06:56'!iniciarinstancia := self new. "Crea una instancia de Juego"instancia dibujarFondo. "Llama al método obtenerCantJug y devuelve su resultado"! !!Juego class methodsFor: 'as yet unclassified' stamp: '2/16/2025 22:40'!jugadaVálida: cantNPC nombreJugador: nombreJugador labelMorph: casilla    | fila columna listaDeFilasValidas listatema maxFila maxColumna |    listaDeFilasValidas := OrderedCollection new.    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.    1 to: cantNPC do: [ :i |        fila := (i - 1) // maxColumna + 1.        columna := (i - 1) \\ maxColumna + 1.        "Verifica si el tema del jugador coincide en la posición actual"        ((TableroLogico matrizDeTemas at: fila column: columna) = nombreJugador tema ) ifTrue: [            "Agrega las posiciones válidas en base a la posición actual"            (fila = 1 and: columna = 1) ifTrue: [                listaDeFilasValidas add: 2@1.                listaDeFilasValidas add: 1@2.            ].            (fila = 1 and: columna = maxColumna) ifTrue: [                listaDeFilasValidas add: 1@(maxColumna - 1).                listaDeFilasValidas add: 2@maxColumna.            ].            (fila = maxFila and: columna = 1) ifTrue: [                listaDeFilasValidas add: (maxFila - 1)@1.                listaDeFilasValidas add: maxFila@2.            ].            (fila = maxFila and: columna = maxColumna) ifTrue: [                listaDeFilasValidas add: maxFila@(maxColumna - 1).                listaDeFilasValidas add: (maxFila - 1)@maxColumna.            ].            (fila = 1 and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: 1@(columna - 1).                listaDeFilasValidas add: 1@(columna + 1).                listaDeFilasValidas add: 2@columna.            ].            (fila = maxFila and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: maxFila@(columna - 1).                listaDeFilasValidas add: maxFila@(columna + 1).                listaDeFilasValidas add: (maxFila - 1)@columna.            ].            (columna = 1 and: (1 < fila and: fila < maxFila)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@1.                listaDeFilasValidas add: (fila + 1)@1.                listaDeFilasValidas add: fila@2.            ].            (columna = maxColumna and: (1 < fila and: fila < maxFila)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@maxColumna.                listaDeFilasValidas add: (fila + 1)@maxColumna.                listaDeFilasValidas add: fila@(maxColumna - 1).            ].            ((1 < fila and: fila < maxFila) and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@columna.                listaDeFilasValidas add: (fila + 1)@columna.                listaDeFilasValidas add: fila@(columna - 1).                listaDeFilasValidas add: fila@(columna + 1).            ].        ].    ].    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.(listaDeFilasValidas includes: ((casilla filaCasilla)@(casilla columnaCasilla)) )ifTrue: [^true] ifFalse: [ ^false].! !!Juego class methodsFor: 'as yet unclassified' stamp: '2/16/2025 21:04'!jugadaVálida: cantNPC nombreJugador: nombreJugador labelMorph: casilla conTema: tema    | fila columna listaDeFilasValidas listatema maxFila maxColumna |    listaDeFilasValidas := OrderedCollection new.    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.    1 to: cantNPC do: [ :i |        fila := (i - 1) // maxColumna + 1.        columna := (i - 1) \\ maxColumna + 1.        "Verifica si el tema del jugador coincide en la posición actual"        ((TableroLogico matrizDeTemas at: fila column: columna) = nombreJugador tema ) ifTrue: [            "Agrega las posiciones válidas en base a la posición actual"            (fila = 1 and: columna = 1) ifTrue: [                listaDeFilasValidas add: 2@1.                listaDeFilasValidas add: 1@2.            ].            (fila = 1 and: columna = maxColumna) ifTrue: [                listaDeFilasValidas add: 1@(maxColumna - 1).                listaDeFilasValidas add: 2@maxColumna.            ].            (fila = maxFila and: columna = 1) ifTrue: [                listaDeFilasValidas add: (maxFila - 1)@1.                listaDeFilasValidas add: maxFila@2.            ].            (fila = maxFila and: columna = maxColumna) ifTrue: [                listaDeFilasValidas add: maxFila@(maxColumna - 1).                listaDeFilasValidas add: (maxFila - 1)@maxColumna.            ].            (fila = 1 and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: 1@(columna - 1).                listaDeFilasValidas add: 1@(columna + 1).                listaDeFilasValidas add: 2@columna.            ].            (fila = maxFila and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: maxFila@(columna - 1).                listaDeFilasValidas add: maxFila@(columna + 1).                listaDeFilasValidas add: (maxFila - 1)@columna.            ].            (columna = 1 and: (1 < fila and: fila < maxFila)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@1.                listaDeFilasValidas add: (fila + 1)@1.                listaDeFilasValidas add: fila@2.            ].            (columna = maxColumna and: (1 < fila and: fila < maxFila)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@maxColumna.                listaDeFilasValidas add: (fila + 1)@maxColumna.                listaDeFilasValidas add: fila@(maxColumna - 1).            ].            ((1 < fila and: fila < maxFila) and: (1 < columna and: columna < maxColumna)) ifTrue: [                listaDeFilasValidas add: (fila - 1)@columna.                listaDeFilasValidas add: (fila + 1)@columna.                listaDeFilasValidas add: fila@(columna - 1).                listaDeFilasValidas add: fila@(columna + 1).            ].        ].    ].    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.(listaDeFilasValidas includes: ((casilla filaCasilla)@(casilla columnaCasilla)) )ifTrue: [^true] ifFalse: [ ^false].! !!Juego class methodsFor: 'accessing' stamp: '2/7/2025 14:19'!desafiante	^ desafiante! !!Juego class methodsFor: 'accessing' stamp: '2/7/2025 14:19'!desafiante: anObject	desafiante := anObject! !!Juego class methodsFor: 'accessing' stamp: '2/7/2025 14:19'!desafiado	^ desafiado! !!Juego class methodsFor: 'accessing' stamp: '2/7/2025 14:19'!desafiado: anObject	desafiado := anObject! !!Juego class methodsFor: 'accessing' stamp: '2/8/2025 19:33'!cantNPCClase	^ cantNPCClase! !!Juego class methodsFor: 'accessing' stamp: '2/8/2025 19:33'!cantNPCClase: anObject	cantNPCClase := anObject! !!Juego class methodsFor: 'accessing' stamp: '2/8/2025 19:33'!jugadordelTurnoActualClase	^ jugadordelTurnoActualClase! !!Juego class methodsFor: 'accessing' stamp: '2/8/2025 19:33'!jugadordelTurnoActualClase: anObject	jugadordelTurnoActualClase := anObject! !!Juego class methodsFor: 'accessing' stamp: '2/15/2025 06:55'!instancia	^ instancia! !!Juego class methodsFor: 'accessing' stamp: '2/15/2025 06:55'!instancia: anObject	instancia := anObject! !Object subclass: #Matrix	instanceVariableNames: 'rows cols data'	classVariableNames: ''	package: 'TheConquist'!!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:08'!rows         ^ rows    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:08'!rows: aNumber         rows := aNumber    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:09'!cols         ^ cols    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:09'!cols: aNumber         cols := aNumber    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:10'!data         ^ data    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:10'!data: anArray         data := anArray    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:10'!at: rowIndex column: colIndex         ^ data at: (rowIndex - 1) * cols + colIndex    ! !!Matrix methodsFor: 'accessing' stamp: '1/23/2025 07:10'!at: rowIndex column: colIndex put: value         data at: (rowIndex - 1) * cols + colIndex put: value    ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Matrix class	instanceVariableNames: ''!!Matrix class methodsFor: 'instance creation' stamp: '1/23/2025 07:11'!rows: rowsNumber columns: colsNumber         | instance |        instance := self new.        instance rows: rowsNumber.        instance cols: colsNumber.        instance data: (Array new: rowsNumber * colsNumber).        ^ instance   ! !Object subclass: #TableroLogico	instanceVariableNames: 'matrizDeTemas matrizTableroLógico matrizDeMorphs punteroJuego'	classVariableNames: ''	package: 'TheConquist'!!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 20:23'!matrizDeMorphs	^ matrizDeMorphs! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 20:23'!matrizDeMorphs: anObject	matrizDeMorphs := anObject! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 20:23'!matrizDeTemas	^ matrizDeTemas! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 20:23'!matrizDeTemas: anObject	matrizDeTemas := anObject! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 20:23'!matrizTableroLógico	^ matrizTableroLógico! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 20:23'!matrizTableroLógico: anObject	matrizTableroLógico := anObject! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 22:31'!punteroJuego:unJuego	punteroJuego:= unJuego.! !!TableroLogico methodsFor: 'accessing' stamp: '2/16/2025 22:31'!punteroJuego	^punteroJuego.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/16/2025 20:11'!crearMatrizMorphs: cantMorphs    | matrizMorphs filas columnas fila columna |    filas := cantMorphs sqrt ceiling.    columnas := cantMorphs sqrt ceiling.    matrizMorphs := Matrix rows: filas columns: columnas.    fila := 1.    columna := 1.    1 to: cantMorphs do: [:i |        | morphcasilla |        morphcasilla := Casilla new.        morphcasilla crearCasilla: fila and: columna label: (self matrizDeTemas at: fila column: columna).        matrizMorphs at: fila column: columna put: morphcasilla.        columna := columna + 1.        (columna > columnas) ifTrue: [            columna := 1.            fila := fila + 1.        ].    ].    self matrizDeMorphs: matrizMorphs.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/17/2025 16:03'!crearMatrizTablero: cantJugadores NPCs: cantNPCs| matrizTablero fila columna cantNPClocal random booleanValue file contents elements jugador |file := FileSystem workingDirectory / 'assets' / 'nombresNPC.txt'.contents := file readStreamDo: [ :stream | stream contents ]."Divide el contenido del archivo en elementos usando '|' como delimitador"elements := contents substrings: '|'.elements := elements shuffled. "Mezclar los elementos"fila := 1.columna := 1.random := Random new.cantNPClocal := cantNPCs."La matriz tablero va a estar compuesta por el objeto jugadores, que contendrá en cada posición los datos del jugador, si es NPC o no, su tema y sus puntos"matrizTablero := Matrix rows: (cantJugadores sqrt ceiling) columns: (cantJugadores sqrt ceiling).1 to: cantJugadores do: [:i |    jugador := Jugador new.    (cantNPClocal > 0) ifTrue: [        cantNPClocal := cantNPClocal - 1.        jugador nombre: (UIManager default request: 'Por favor ingrese el nombre del participante').    ] ifFalse: [        jugador nombre: (elements atRandom).    ].    jugador puntosProbabilidad: 0.    jugador tema: (self matrizDeTemas at: fila column: columna).    matrizTablero at: fila column: columna put: jugador.    (fila = matrizTablero rows) ifTrue: [        fila := 1.        columna := columna + 1.    ] ifFalse: [        fila := fila + 1.    ].].self matrizTableroLógico: matrizTablero.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/16/2025 20:13'!crearMatrizTemas: cantJugadores| file contents elements matrix matrixSize |"Abre el archivo y lee su contenido"file := FileSystem workingDirectory / 'assets' / 'temas.txt'.contents := file readStreamDo: [ :stream | stream contents ]."Divide el contenido del archivo en elementos usando '|' como delimitador"elements := contents substrings: '|'.elements := elements shuffled."Crear la matriz"matrixSize := cantJugadores sqrt.matrix := Matrix rows: matrixSize columns: matrixSize."Recorrer los elementos y asignarlos a la matriz"1 to: (matrixSize * matrixSize) do: [:i |    | row col |    row := (i - 1) // matrixSize + 1.  "Calcula la fila"    col := (i - 1) \\ matrixSize + 1.   "Calcula la columna"    (i <= elements size) ifTrue: [        matrix at: row column: col put: (elements at: i).    ] ifFalse: [        matrix at: row column: col put: nil. "O algún valor por defecto"    ].].self matrizDeTemas: matrix.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/17/2025 16:04'!dibujarTablero|Casilla fila columna|fila := 0.columna := 1.1 to: (punteroJuego cantJugadores) do:[:i|	fila := fila + 1.	Casilla := TableroLogico matrizDeMorphs at: fila column: columna.	(fila = (punteroJuego cantJugadores sqrt)) ifTrue: [fila := 1. columna := columna + 1].	punteroJuego imagenMorph addMorph: Casilla.	Casilla position: (10*i)@(10*i).	]! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/17/2025 16:01'!dibujarTablero: imagenMorph|Casilla fila columna|fila := 0.columna := 1.1 to: (punteroJuego cantJugadores) do:[:i|	fila := fila + 1.	Casilla := self matrizDeMorphs at: fila column: columna.	(fila = (punteroJuego cantJugadores sqrt ceiling)) ifTrue: [fila := 1. columna := columna + 1].	imagenMorph addMorph: Casilla.	Casilla position: (10*i)@(10*i).	]! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/16/2025 20:14'!dibujarTablero: imagenMorph cantNPC: cantNPC    | casilla fila columna maxFila maxColumna |    fila := 1.    columna := 1.    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.    1 to: cantNPC do: [:i |        casilla := (self matrizDeMorphs at: fila column: columna) morph.        imagenMorph addMorph: casilla.        casilla position: ((columna - 1) * 120) @ ((fila - 1) * 120). "Ajusta la posición según sea necesario"        columna := columna + 1.        (columna > maxColumna) ifTrue: [            columna := 1.            fila := fila + 1.        ].    ].! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/16/2025 20:12'!obtenerJugadorTurnoActual| listaPrioridad prioridadMáxima fila columna jugadorDeMatriz |prioridadMáxima := 0.listaPrioridad := OrderedCollection new.fila := 1.columna := 1.1 to: Juego class cantNPC do: [ :i |    jugadorDeMatriz := (self matrizTableroLógico at: fila column: columna).    (jugadorDeMatriz puntosProbabilidad = prioridadMáxima) ifTrue: [         listaPrioridad add: jugadorDeMatriz     ].    (jugadorDeMatriz puntosProbabilidad > prioridadMáxima) ifTrue: [         listaPrioridad := OrderedCollection with: jugadorDeMatriz.        prioridadMáxima := jugadorDeMatriz puntosProbabilidad     ].    fila := fila + 1.    (fila > (Juego class cantNPC sqrt ceiling)) ifTrue: [         fila := 1.        columna := columna + 1     ].].jugadorDeMatriz := (listaPrioridad atRandom).^jugadorDeMatriz.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/17/2025 16:28'!obtenerJugadorTurnoActual: cantJugadores| listaPrioridad prioridadMáxima fila columna jugadorDeMatriz |prioridadMáxima := 999.listaPrioridad := OrderedCollection new.fila := 1.columna := 1.1 to: cantJugadores do: [ :i |    jugadorDeMatriz := (self matrizTableroLógico at: fila column: columna).    "Verifica si los puntos son menores que la prioridad máxima actual"    (jugadorDeMatriz puntosProbabilidad < prioridadMáxima)        ifTrue: [             "Reinicia la lista con el nuevo jugador y actualiza la prioridad"            listaPrioridad := OrderedCollection with: jugadorDeMatriz.            prioridadMáxima := jugadorDeMatriz puntosProbabilidad         ]        ifFalse: [            "Si los puntos son iguales a la prioridad máxima, agrega al jugador"            (jugadorDeMatriz puntosProbabilidad = prioridadMáxima)                ifTrue: [ listaPrioridad add: jugadorDeMatriz ]        ].    "Avanza en la matriz del tablero lógico"    fila := fila + 1.    (fila > (cantJugadores sqrt ceiling)) ifTrue: [         fila := 1.        columna := columna + 1     ].]."Selecciona un jugador al azar de la lista de prioridad"jugadorDeMatriz := listaPrioridad atRandom.^jugadorDeMatriz! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/16/2025 20:37'!crearMatrizMorphs: cantMorphs enJuego:juego    | matrizMorphs filas columnas fila columna |    filas := cantMorphs sqrt ceiling.    columnas := cantMorphs sqrt ceiling.    matrizMorphs := Matrix rows: filas columns: columnas.    fila := 1.    columna := 1.    1 to: cantMorphs do: [:i |        | morphcasilla |        morphcasilla := Casilla new.		  morphcasilla punteroJuego: juego.        morphcasilla crearCasilla: fila and: columna label: (self matrizDeTemas at: fila column: columna).        matrizMorphs at: fila column: columna put: morphcasilla.        columna := columna + 1.        (columna > columnas) ifTrue: [            columna := 1.            fila := fila + 1.        ].    ].    self matrizDeMorphs: matrizMorphs.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/16/2025 22:36'!crearMatrizTablero: cantJugadores| matrizTablero fila columna random jugador cantidadJugadores|fila := 1.columna := 1.random := Random new.cantidadJugadores:= cantJugadores."La matriz tablero va a estar compuesta por el objeto jugadores, que contendrá en cada posición los datos del jugador, si es NPC o no, su tema y sus puntos"matrizTablero := Matrix rows: (cantidadJugadores sqrt ceiling) columns: (cantidadJugadores sqrt ceiling).1 to: cantJugadores do: [:i |    jugador := Jugador new.        jugador nombre: (UIManager default request: 'Por favor ingrese el nombre del participante').    jugador puntosProbabilidad: 0.    jugador tema: (self matrizDeTemas at: fila column: columna).    matrizTablero at: fila column: columna put: jugador.    (fila = matrizTablero rows) ifTrue: [        fila := 1.        columna := columna + 1.    ] ifFalse: [        fila := fila + 1.    ].].self matrizTableroLógico: matrizTablero.! !!TableroLogico methodsFor: 'CreacionyManejoDeMatrices' stamp: '2/17/2025 16:20'!obtenerJugadorTurnoActualboton: cantJugadores    | listaPrioridad listaOrdenada fila columna jugadorDeMatriz |    listaPrioridad := OrderedCollection new.    fila := 1.    columna := 1.    1 to: cantJugadores do: [ :i |        jugadorDeMatriz := (self matrizTableroLógico at: fila column: columna).        listaPrioridad add: jugadorDeMatriz.        fila := fila + 1.        (fila > (cantJugadores sqrt ceiling)) ifTrue: [             fila := 1.            columna := columna + 1          ].    ].        "Ordenamos la lista por prioridad ascendente"    listaOrdenada := listaPrioridad sorted: [:a :b | a puntosProbabilidad < b puntosProbabilidad].        "Seleccionamos el siguiente en la lista, si hay más de uno"    jugadorDeMatriz := (listaOrdenada size > 1)        ifTrue: [ listaOrdenada second ]        ifFalse: [ listaOrdenada first ].        Transcript show: jugadorDeMatriz tema.    ^jugadorDeMatriz.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TableroLogico class	instanceVariableNames: 'MatrizDeTemas MatrizTableroLógico MatrizDeMorphs'!!TableroLogico class methodsFor: 'accessing' stamp: '1/25/2025 22:14'!matrizDeTemas	^ MatrizDeTemas! !!TableroLogico class methodsFor: 'accessing' stamp: '1/25/2025 22:14'!matrizDeTemas: anObject	MatrizDeTemas := anObject! !!TableroLogico class methodsFor: 'accessing' stamp: '1/27/2025 12:34'!matrizTableroLógico	^ MatrizTableroLógico! !!TableroLogico class methodsFor: 'accessing' stamp: '1/27/2025 12:34'!matrizTableroLógico: anObject	MatrizTableroLógico := anObject! !!TableroLogico class methodsFor: 'accessing' stamp: '1/27/2025 17:11'!matrizDeMorphs	^ MatrizDeMorphs! !!TableroLogico class methodsFor: 'accessing' stamp: '1/27/2025 17:11'!matrizDeMorphs: anObject	MatrizDeMorphs := anObject! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '2/9/2025 00:58'!crearMatrizMorphs: cantMorphs    | matrizMorphs filas columnas fila columna |    filas := cantMorphs sqrt ceiling.    columnas := cantMorphs sqrt ceiling.    matrizMorphs := Matrix rows: filas columns: columnas.    fila := 1.    columna := 1.    1 to: cantMorphs do: [:i |        | morphcasilla |        morphcasilla := Casilla new.        morphcasilla crearCasilla: fila and: columna label: (self matrizDeTemas at: fila column: columna).        matrizMorphs at: fila column: columna put: morphcasilla.        columna := columna + 1.        (columna > columnas) ifTrue: [            columna := 1.            fila := fila + 1.        ].    ].    self matrizDeMorphs: matrizMorphs.! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '2/15/2025 05:20'!crearMatrizTablero: cantJugadores NPCs: cantNPCs| matrizTablero fila columna cantNPClocal random booleanValue file contents elements jugador |file := FileSystem workingDirectory / 'assets' / 'nombresNPC.txt'.contents := file readStreamDo: [ :stream | stream contents ]."Divide el contenido del archivo en elementos usando '|' como delimitador"elements := contents substrings: '|'.elements := elements shuffled. "Mezclar los elementos"fila := 1.columna := 1.random := Random new.cantNPClocal := cantNPCs."La matriz tablero va a estar compuesta por el objeto jugadores, que contendrá en cada posición los datos del jugador, si es NPC o no, su tema y sus puntos"matrizTablero := Matrix rows: (cantJugadores sqrt ceiling) columns: (cantJugadores sqrt ceiling).1 to: cantJugadores do: [:i |    jugador := Jugador new.    (cantNPClocal > 0) ifTrue: [        cantNPClocal := cantNPClocal - 1.        jugador nombre: (UIManager default request: 'Por favor ingrese el nombre del participante').        jugador nPC: false.    ] ifFalse: [        jugador nombre: (elements atRandom).        jugador nPC: true.    ].    jugador puntosProbabilidad: 0.    jugador tema: (TableroLogico matrizDeTemas at: fila column: columna).    matrizTablero at: fila column: columna put: jugador.    (fila = matrizTablero rows) ifTrue: [        fila := 1.        columna := columna + 1.    ] ifFalse: [        fila := fila + 1.    ].].self matrizTableroLógico: matrizTablero.! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '1/25/2025 22:17'!crearMatrizTemas: cantJugadores| file contents elements matrix matrixSize |"Abre el archivo y lee su contenido"file := FileSystem workingDirectory / 'assets' / 'temas.txt'.contents := file readStreamDo: [ :stream | stream contents ]."Divide el contenido del archivo en elementos usando '|' como delimitador"elements := contents substrings: '|'.elements := elements shuffled."Crear la matriz"matrixSize := cantJugadores sqrt.matrix := Matrix rows: matrixSize columns: matrixSize."Recorrer los elementos y asignarlos a la matriz"1 to: (matrixSize * matrixSize) do: [:i |    | row col |    row := (i - 1) // matrixSize + 1.  "Calcula la fila"    col := (i - 1) \\ matrixSize + 1.   "Calcula la columna"    (i <= elements size) ifTrue: [        matrix at: row column: col put: (elements at: i).    ] ifFalse: [        matrix at: row column: col put: nil. "O algún valor por defecto"    ].].MatrizDeTemas := matrix.! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '1/31/2025 21:23'!dibujarTablero|Casilla fila columna|fila := 0.columna := 1.1 to: (Juego cantNPC) do:[:i|	fila := fila + 1.	Casilla := TableroLogico matrizDeMorphs at: fila column: columna.	(fila = (Juego cantNPC sqrt)) ifTrue: [fila := 1. columna := columna + 1].	Juego imagenMorph addMorph: Casilla.	Casilla position: (10*i)@(10*i).	]! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '1/31/2025 21:24'!dibujarTablero: imagenMorph|Casilla fila columna|fila := 0.columna := 1.1 to: (Juego cantNPC) do:[:i|	fila := fila + 1.	Casilla := TableroLogico matrizDeMorphs at: fila column: columna.	(fila = (Juego cantNPC sqrt)) ifTrue: [fila := 1. columna := columna + 1].	imagenMorph addMorph: Casilla.	Casilla position: (10*i)@(10*i).	]! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '2/9/2025 00:58'!dibujarTablero: imagenMorph cantNPC: cantNPC    | casilla fila columna maxFila maxColumna |    fila := 1.    columna := 1.    maxFila := cantNPC sqrt ceiling.    maxColumna := cantNPC sqrt ceiling.    1 to: cantNPC do: [:i |        casilla := (TableroLogico matrizDeMorphs at: fila column: columna) morph.        imagenMorph addMorph: casilla.        casilla position: ((columna - 1) * 120) @ ((fila - 1) * 120). "Ajusta la posición según sea necesario"        columna := columna + 1.        (columna > maxColumna) ifTrue: [            columna := 1.            fila := fila + 1.        ].    ].! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '2/15/2025 15:54'!obtenerJugadorTurnoActual| listaPrioridad prioridadMáxima fila columna jugadorDeMatriz |prioridadMáxima := 0.listaPrioridad := OrderedCollection new.fila := 1.columna := 1.1 to: Juego class cantNPC do: [ :i |    jugadorDeMatriz := (self matrizTableroLógico at: fila column: columna).    (jugadorDeMatriz puntosProbabilidad = prioridadMáxima) ifTrue: [         listaPrioridad add: jugadorDeMatriz     ].    (jugadorDeMatriz puntosProbabilidad > prioridadMáxima) ifTrue: [         listaPrioridad := OrderedCollection with: jugadorDeMatriz.        prioridadMáxima := jugadorDeMatriz puntosProbabilidad     ].    fila := fila + 1.    (fila > (Juego class cantNPC sqrt ceiling)) ifTrue: [         fila := 1.        columna := columna + 1     ].].jugadorDeMatriz := (listaPrioridad atRandom).^jugadorDeMatriz.! !!TableroLogico class methodsFor: 'CreaciónyManejodeMAtrices' stamp: '2/7/2025 15:21'!obtenerJugadorTurnoActual: CantNPC| listaPrioridad prioridadMáxima fila columna jugadorDeMatriz |prioridadMáxima := 0.listaPrioridad := OrderedCollection new.fila := 1.columna := 1.1 to: CantNPC do: [ :i |    jugadorDeMatriz := (self matrizTableroLógico at: fila column: columna).    (jugadorDeMatriz puntosProbabilidad = prioridadMáxima) ifTrue: [         listaPrioridad add: jugadorDeMatriz     ].    (jugadorDeMatriz puntosProbabilidad > prioridadMáxima) ifTrue: [         listaPrioridad := OrderedCollection with: jugadorDeMatriz.        prioridadMáxima := jugadorDeMatriz puntosProbabilidad     ].    fila := fila + 1.    (fila > (CantNPC sqrt ceiling)) ifTrue: [         fila := 1.        columna := columna + 1     ].].jugadorDeMatriz := (listaPrioridad atRandom).^jugadorDeMatriz.! !Object subclass: #DueloMC	instanceVariableNames: 'temaDuelo desafianteDuelo desafiadoDuelo tableroDeDuelo morphnombre1 morphnombre2 morphTiempo1 morphTiempo2 puntosDesafiado puntosDesafiante puntosMorph1 puntosMorph2 morphImagen listaNombres nombreDelaImagen jugadorActual tiempoDesafiante tiempoDesafiado temaGanador cantidadDuelo jugadorGanador jugadorPerdedor aux1 aux2 punteroJuego'	classVariableNames: ''	package: 'TheConquist'!!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:58'!cantidadDuelo: argumento	cantidadDuelo:= argumento! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:58'!cantidadDuelo	^cantidadDuelo! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:58'!desafiadoDuelo: anObject	desafiadoDuelo := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:58'!desafiadoDuelo	^ desafiadoDuelo! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!desafianteDuelo	^ desafianteDuelo! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!desafianteDuelo: anObject	desafianteDuelo := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!jugadorActual	^ jugadorActual! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!jugadorActual: anObject	jugadorActual := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!jugadorGanador	^ jugadorGanador! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!jugadorGanador: anObject	jugadorGanador := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!jugadorPerdedor	^ jugadorPerdedor! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!jugadorPerdedor: anObject	jugadorPerdedor := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!listaNombres	^ listaNombres! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!listaNombres: anObject	listaNombres := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!morphImagen	^ morphImagen! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!morphImagen: anObject	morphImagen := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!morphTiempo1	^ morphTiempo1! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!morphTiempo1: anObject	morphTiempo1 := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 19:59'!morphTiempo2	^ morphTiempo2! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!morphTiempo2: anObject	morphTiempo2 := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!morphnombre1	^ morphnombre1! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!morphnombre1: anObject	morphnombre1 := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!morphnombre2	^ morphnombre2! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!morphnombre2: anObject	morphnombre2 := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!nombreDelaImagen	^ nombreDelaImagen! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!nombreDelaImagen: anObject	nombreDelaImagen := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosDesafiado	^ puntosDesafiado! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosDesafiado: anObject	puntosDesafiado := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosDesafiante	^ puntosDesafiante! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosDesafiante: anObject	puntosDesafiante := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosMorph1	^ puntosMorph1! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosMorph1: anObject	puntosMorph1 := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosMorph2	^ puntosMorph2! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!puntosMorph2: anObject	puntosMorph2 := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!tableroDeDuelo	^ tableroDeDuelo! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!tableroDeDuelo: anObject	tableroDeDuelo := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!temaDuelo	^ temaDuelo! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:00'!temaDuelo: anObject	temaDuelo := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:01'!temaGanador	^ temaGanador! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:01'!temaGanador: anObject	temaGanador := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:01'!tiempoDesafiado	^ tiempoDesafiado! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:01'!tiempoDesafiado: anObject	tiempoDesafiado := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:01'!tiempoDesafiante	^ tiempoDesafiante! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:01'!tiempoDesafiante: anObject	tiempoDesafiante := anObject! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:51'!punteroJuego: unJuego	punteroJuego:= unJuego.! !!DueloMC methodsFor: 'accessing' stamp: '2/16/2025 20:51'!punteroJuego	^punteroJuego! !!DueloMC methodsFor: 'initialize' stamp: '2/17/2025 15:25'!initializeself puntosDesafiado: 0.self puntosDesafiante:0.self tiempoDesafiante:30.self tiempoDesafiado:30.! !!DueloMC methodsFor: 'initialize' stamp: '2/17/2025 15:25'!initializeDeluxeself puntosDesafiado: 0.self puntosDesafiante:0.self tiempoDesafiante:15.self tiempoDesafiado:15.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:38'!botonclickeado: parametro(parametro = self nombreDelaImagen) ifTrue: [	(self jugadorActual) ifTrue: [		self incrementarPuntosMorph1.	] ifFalse: [		self incrementarPuntosMorph2.]	]ifFalse: [ 		(jugadorActual) ifTrue: 			[self penalizaciónTiempo1			] ifFalse: 				[self penalizaciónTiempo2 ]]! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:48'!controlDeTiempos    | procesoDesafiante procesoDesafiado detener  |    detener := false.     procesoDesafiante := [        [self jugadorActual and: [detener not]] whileTrue: [            (self tiempoDesafiante > 0) ifTrue: [                1 second wait.                self tiempoDesafiante: self tiempoDesafiante - 1.                self decrementarTiempo1.            ].            (self tiempoDesafiante <= 0) ifTrue: [                jugadorActual := false.                detener := true.((self tiempoDesafiado <= 0) and: (self tiempoDesafiante <= 0)) ifTrue:[self determinarGanador]. ((self tiempoDesafiado > 0) xor: (self tiempoDesafiante > 0)) ifTrue:[self controlDeTiempos].            ].        ].    ] fork.    procesoDesafiado := [        [(self jugadorActual not) and: [detener not]] whileTrue: [            (self tiempoDesafiado > 0) ifTrue: [                1 second wait.                self tiempoDesafiado: self tiempoDesafiado - 1.                self decrementarTiempo2.            ].            (self tiempoDesafiado <= 0) ifTrue: [                jugadorActual := true.                detener := true.((self tiempoDesafiado <= 0) and: (self tiempoDesafiante <= 0)) ifTrue:[self determinarGanador]. ((self tiempoDesafiado > 0) xor: (self tiempoDesafiante > 0)) ifTrue:[self controlDeTiempos].            ].        ].    ] fork.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:36'!crearBotones	| boton1 boton2 boton3 boton4 boton5 coleccionBotones listaParaCargarBotones |listaParaCargarBotones := OrderedCollection new.listaParaCargarBotones add: self nombreDelaImagen.1 to: 3 do: [:i|listaParaCargarBotones add: (self listaNombres at: i ).].listaParaCargarBotones shuffle.	boton1 := SimpleButtonMorph new.	boton1		label: (listaParaCargarBotones at: 1);		extent: 200 @ 100;		on: #mouseUp send: #value to: [self botonclickeado: (listaParaCargarBotones at: 1)];		position: 0 @ 0.	boton2 := SimpleButtonMorph new.	boton2		label: (listaParaCargarBotones at: 2);		extent: 200 @ 100;		on: #mouseUp send: #value to: [self botonclickeado: (listaParaCargarBotones at: 2)];		position: 0 @ 150.	boton3 := SimpleButtonMorph new.	boton3		label: (listaParaCargarBotones at: 3);		extent: 200 @ 100;		on: #mouseUp send: #value to: [self botonclickeado: (listaParaCargarBotones at: 3)];		position: 300 @ 0.	boton4 := SimpleButtonMorph new.	boton4		label: (listaParaCargarBotones at: 4);		extent: 200 @ 100;		on: #mouseUp send: #value to: [self botonclickeado: (listaParaCargarBotones at: 4)];		position: 300 @ 150.		boton5 := SimpleButtonMorph new.	boton5		label: ('Saltar');		extent: 200 @ 100;		on: #mouseUp send: #value to: [self jugadorActual: (self jugadorActual) not. self controlDeTiempos];		position: 600 @ 150.	coleccionBotones := Morph new.	coleccionBotones 		addMorph: boton1 ;		addMorph: boton2 ;		addMorph: boton3 ;		addMorph: boton4 ;		addMorph: boton5.coleccionBotones position: (self tableroDeDuelo extent x //2 ) - coleccionBotones extent x - 250	@ (self tableroDeDuelo extent y //2 ) - coleccionBotones extent y.self tableroDeDuelo addMorph: coleccionBotones.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/17/2025 17:28'!crearMorphNombres: desafianteNombre desafiadoNombre: desafiadoNombre    | text1 text2 morph1position morph2position font textMorph1 textMorph2|font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Crear el Morph para contener el texto del desafianteNombre"    self morphnombre1: Morph new.    self morphnombre1 extent: 200 @ 75.    self morphnombre1 color: Color gray.        "Crear el TextMorph para el desafianteNombre"    text1 := desafianteNombre asUppercase asText    addAttribute: font;    addAttribute: (TextColor new color: Color red).    "Centrar el texto dentro del morphnombre1"textMorph1 := TextMorph new.textMorph1 contents: text1. textMorph1 position: ((morphnombre1 extent - textMorph1 extent) // 2).    morphnombre1 addMorph: textMorph1.        "Suponiendo que tableroDeDuelo ya está definido como un ImageMorph"    "tableroDeDuelo := ImageMorph new. Esto es solo un placeholder, deberías tener ya tu tablero de duelo definido"        "Agregar morphnombre1 a tableroDeDuelo"    tableroDeDuelo addMorph: morphnombre1.        "Posicionar el morphnombre1 en la posición deseada"    morph1position := ((tableroDeDuelo extent x)) - (World width) @ ((tableroDeDuelo extent y //2 )) - (World height //2 ).    morphnombre1 position: morph1position.    "Crear el Morph para contener el texto del desafianteNombre"    morphnombre2 := Morph new.    morphnombre2 extent: 200 @ 75.    morphnombre2 color: Color gray.        "Crear el TextMorph para el desafianteNombre"    text2 := desafiadoNombre asUppercase asText    addAttribute: font;    addAttribute: (TextColor new color: Color red).    "Centrar el texto dentro del morphnombre1"textMorph2 := TextMorph new.textMorph2 contents: text2. textMorph2 position: ((morphnombre1 extent - textMorph2 extent) // 2).    morphnombre2 addMorph: textMorph2.        "Suponiendo que tableroDeDuelo ya está definido como un ImageMorph"    "tableroDeDuelo := ImageMorph new. Esto es solo un placeholder, deberías tener ya tu tablero de duelo definido"        "Agregar morphnombre1 a tableroDeDuelo"    tableroDeDuelo addMorph: morphnombre2.        "Posicionar el morphnombre1 en la posición deseada"    morph2position := ((tableroDeDuelo extent x //2 )) + (World width // 2) @ ((tableroDeDuelo extent y //2 )) - (World height //2 ) .    morphnombre2 position: morph2position.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:14'!crearMorphTimmer: tiempo1 timmer2: tiempo2    | text1 text2 morph1position morph2position font textMorph1 textMorph2 time1 time2|time1 := (self tiempoDesafiante) asNumber.time2 := (self tiempoDesafiado) asNumber.font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Crear el Morph para contener el texto del desafianteNombre"    self morphTiempo1: Morph new.    self morphTiempo1 extent: 200 @ 75.    self morphTiempo1 color: Color gray.        "Crear el TextMorph para el desafianteNombre"    text1 := (time1 asString) asText    addAttribute: font;    addAttribute: (TextColor new color: Color red).    "Centrar el texto dentro del morphnombre1"	 textMorph1 := TextMorph new.	 textMorph1 contents: text1. 	 textMorph1 position: ((self morphTiempo1 extent - textMorph1 extent) // 2).    self morphTiempo1 addMorph: textMorph1.        "Suponiendo que tableroDeDuelo ya está definido como un ImageMorph"    "tableroDeDuelo := ImageMorph new. Esto es solo un placeholder, deberías tener ya tu tablero de duelo definido"        "Agregar morphnombre1 a tableroDeDuelo"    self tableroDeDuelo addMorph: self morphTiempo1.        "Posicionar el morphnombre1 en la posición deseada"    morph1position := (self morphnombre1) position x - 100  @ (self morphnombre1) position y + 100.    self morphTiempo1 position: morph1position.    "Crear el Morph para contener el texto del desafianteNombre"    self morphTiempo2: Morph new.    self morphTiempo2 extent: 200 @ 75.    self morphTiempo2 color: Color gray.        "Crear el TextMorph para el desafianteNombre"    text2 := (time2 asString) asText    addAttribute: font;    addAttribute: (TextColor new color: Color red).    "Centrar el texto dentro del morphnombre1"textMorph2 := TextMorph new.textMorph2 contents: text2. textMorph2 position: ((self morphTiempo2 extent - textMorph2 extent) // 2).    self morphTiempo2 addMorph: textMorph2.        "Suponiendo que tableroDeDuelo ya está definido como un ImageMorph"    "tableroDeDuelo := ImageMorph new. Esto es solo un placeholder, deberías tener ya tu tablero de duelo definido"        "Agregar morphnombre1 a tableroDeDuelo"    self tableroDeDuelo addMorph: morphTiempo2.        "Posicionar el morphnombre1 en la posición deseada"    morph2position := (self morphnombre2) position x -100 @ (self morphnombre2) position y + 100.    (self morphTiempo2) position: morph2position.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:35'!crearMorphimagen|imagen directoryPath fileNames nombreimagen screenWidth screenHeight |screenWidth := World width.screenHeight := World height.directoryPath := FileSystem workingDirectory / 'assets/images'/(self temaDuelo)asString.fileNames := OrderedCollection new.directoryPath entries do: [:entry |    entry isDirectory ifFalse: [fileNames add: entry name]].nombreimagen := fileNames atRandom.imagen := Form fromFileNamed:                FileSystem workingDirectory                / 'assets/images'/((self temaDuelo))asString/nombreimagen. self morphImagen ifNotNil: [ self tableroDeDuelo removeMorph: self morphImagen ].self morphImagen: ImageMorph new.self morphImagen        image: imagen;        position: ((self tableroDeDuelo extent x // 2) - (self morphImagen width // 2))  @ ((self tableroDeDuelo extent y // 2) - (self morphImagen height // 2))-100.self tableroDeDuelo addMorph: self morphImagen.fileNames remove: nombreimagen.self listaNombres: fileNames.self nombreDelaImagen: nombreimagen.self crearBotones.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 20:04'!crearMorphsPuntos    | text1 text2 morph1position morph2position font textMorph1 textMorph2 puntos1 puntos2|puntos1 := puntosDesafiante asNumber.puntos2 := puntosDesafiado asNumber.font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Crear el Morph para contener el texto del desafianteNombre"    puntosMorph1 := Morph new.    puntosMorph1 extent: 200 @ 75.    puntosMorph1 color: Color gray.        "Crear el TextMorph para el desafianteNombre"    text1 := (puntosDesafiante asString) asText    addAttribute: font;    addAttribute: (TextColor new color: Color red).    "Centrar el texto dentro del morphnombre1"textMorph1 := TextMorph new.textMorph1 contents: text1. textMorph1 position: ((puntosMorph1 extent - textMorph1 extent) // 2).    puntosMorph1 addMorph: textMorph1.        "Suponiendo que tableroDeDuelo ya está definido como un ImageMorph"    "tableroDeDuelo := ImageMorph new. Esto es solo un placeholder, deberías tener ya tu tablero de duelo definido"        "Agregar morphnombre1 a tableroDeDuelo"    tableroDeDuelo addMorph: puntosMorph1.        "Posicionar el morphnombre1 en la posición deseada"    morph1position := morphnombre1 position x - 200  @ morphnombre1 position y + 200.    puntosMorph1 position: morph1position.    "Crear el Morph para contener el texto del desafianteNombre"    puntosMorph2 := Morph new.    puntosMorph2 extent: 200 @ 75.    puntosMorph2 color: Color gray.        "Crear el TextMorph para el desafianteNombre"    text2 := (puntosDesafiado asString) asText    addAttribute: font;    addAttribute: (TextColor new color: Color red).    "Centrar el texto dentro del morphnombre1"textMorph2 := TextMorph new.textMorph2 contents: text2. textMorph2 position: ((puntosMorph2 extent - textMorph2 extent) // 2).    puntosMorph2 addMorph: textMorph2.        "Suponiendo que tableroDeDuelo ya está definido como un ImageMorph"    "tableroDeDuelo := ImageMorph new. Esto es solo un placeholder, deberías tener ya tu tablero de duelo definido"        "Agregar morphnombre1 a tableroDeDuelo"    tableroDeDuelo addMorph: puntosMorph2.        "Posicionar el morphnombre1 en la posición deseada"    morph2position := morphnombre2 position x -200   @ morphnombre2 position y + 200.    puntosMorph2 position: morph2position.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:46'!decrementarTiempo1    | nuevoPunto textMorph1 font newText |    font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Incrementar el valor de puntosDesafiante"        "Encontrar el TextMorph dentro de puntosMorph1"    textMorph1 := self morphTiempo1 submorphs detect: [:each | each isKindOf: TextMorph].        "Crear el nuevo texto con atributos"    newText := (self tiempoDesafiante asString asText).    newText addAttribute: font.    newText addAttribute: (TextColor new color: Color red).        "Actualizar el contenido del TextMorph"    textMorph1 contents: newText.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 20:04'!decrementarTiempo2    | nuevoPunto textMorph1 font newText |    font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Incrementar el valor de puntosDesafiante"        "Encontrar el TextMorph dentro de puntosMorph1"    textMorph1 := morphTiempo2 submorphs detect: [:each | each isKindOf: TextMorph].        "Crear el nuevo texto con atributos"    newText := (tiempoDesafiado asString asText).    newText addAttribute: font.    newText addAttribute: (TextColor new color: Color red).        "Actualizar el contenido del TextMorph"    textMorph1 contents: newText.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/17/2025 16:09'!determinarGanador    | jugadorDesafiado fila columna|    fila := 1.    columna := 1.    1 to: punteroJuego cantJugadores do: [ :index |         "Iteramos sobre la matriz TableroLogico"        (fila > punteroJuego cantJugadores sqrt ceiling) ifTrue: [             fila := 1.             columna := columna + 1         ].        (((punteroJuego tableroLogico matrizTableroLógico at: fila column: columna) tema) = (self temaDuelo)) ifTrue: [             jugadorDesafiado := (punteroJuego tableroLogico matrizTableroLógico at: fila column: columna)        ].        fila := fila + 1.    ].    (self puntosDesafiante > self puntosDesafiado) ifTrue: [         self jugadorGanador: punteroJuego jugadorActual.        self jugadorPerdedor: jugadorDesafiado.    ] ifFalse: [          self jugadorGanador: jugadorDesafiado.         self jugadorPerdedor: punteroJuego jugadorActual.     ].self eliminarVentanasDuelo.self ganaDesafiante: (aux1) desafiado: aux2.aux1 puntosProbabilidad: (aux1 puntosProbabilidad + 1).self punteroJuego flujoPrincipalPostDuelo.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:08'!dibujarDuelo| imagen barra tamañoWorld ventana  |imagen := Form fromFileNamed: (FileSystem workingDirectory / 'assets' / 'backgrounds' / 'background-duel.jpg') fullName.self tableroDeDuelo: ImageMorph new.self tableroDeDuelo image: imagen.self tableroDeDuelo position: 0@0.barra := ScrollPane new.barra scroller addMorph: self tableroDeDuelo.barra extent: 300@300."Set the scroll position to the middle"barra scrollValue: ((0.1)@ (0.2)).tamañoWorld := World extent.ventana := SystemWindow labelled: 'Duelo'.ventana addMorph: barra frame: (0@0 corner: 1@1).[    ventana        position: 0 @ 0;        extent: tamañoWorld;        borderWidth: 0.] ensure: [ ventana openInWorld ].! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 20:04'!eliminarVentanasDuelo    "Elimina todas las instancias de SystemWindow etiquetadas con 'Duelo'"    SystemWindow allInstances do: [ :cadaVentana |         (cadaVentana label = 'Duelo') ifTrue: [ cadaVentana delete ].    ].! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 22:47'!incrementarPuntosMorph1    | nuevoPunto textMorph1 font newText |    font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Incrementar el valor de puntosDesafiante"    self puntosDesafiante: (self puntosDesafiante + 1).        "Encontrar el TextMorph dentro de puntosMorph1"    textMorph1 := self puntosMorph1 submorphs detect: [:each | each isKindOf: TextMorph].        "Crear el nuevo texto con atributos"    newText := (self puntosDesafiante asString asText).    newText addAttribute: font.    newText addAttribute: (TextColor new color: Color red).    	"Actualizar el contenido del TextMorph"	textMorph1 contents: newText.	self crearMorphimagen.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 20:05'!incrementarPuntosMorph2    | nuevoPunto textMorph1 font newText |    font := (TextFontReference toFont: (StrikeFont familyName: 'Bitmap DejaVu Sans' size: 150)).    "Incrementar el valor de puntosDesafiante"    self puntosDesafiado: (self puntosDesafiado + 1).        "Encontrar el TextMorph dentro de puntosMorph1"    textMorph1 := puntosMorph2 submorphs detect: [:each | each isKindOf: TextMorph].        "Crear el nuevo texto con atributos"    newText := (self puntosDesafiado asString asText).    newText addAttribute: font.    newText addAttribute: (TextColor new color: Color red).        "Actualizar el contenido del TextMorph"    textMorph1 contents: newText.self crearMorphimagen.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 20:05'!penalizaciónTiempo1(tiempoDesafiante := tiempoDesafiante - 10).tiempoDesafiante <0 ifTrue:[ tiempoDesafiante := 1].self decrementarTiempo1.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 20:05'!penalizaciónTiempo2(tiempoDesafiado := tiempoDesafiado - 10).tiempoDesafiado <0 ifTrue:[tiempoDesafiado := 1].self decrementarTiempo2.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 21:07'!iniciarDueloEnJuego:unJuego conTema: unTema 	| jugadorDesafiado fila columna cantidadJugadores tablero|	self punteroJuego: unJuego.	tablero:= self punteroJuego tableroLogico.	fila := 1.	columna := 1.	cantidadJugadores:= unJuego cantJugadores.	self temaDuelo: unTema.		1 to: cantidadJugadores do: [ :index | 		"Iteramos sobre la matriz TableroLogico"		(fila > cantidadJugadores sqrt ceiling) ifTrue: [ 			fila := 1. 			columna := columna + 1 			].		(((tablero matrizTableroLógico at: fila column: columna) tema) = (self temaDuelo)) ifTrue: [ 			jugadorDesafiado := (tablero matrizTableroLógico at: fila column: columna)			].		fila := fila + 1.		].self initialize.self jugadorActual: true.self dibujarDuelo.self crearMorphNombres: (punteroJuego jugadorActual nombre asString) desafiadoNombre: jugadorDesafiado nombre asString. aux1 := punteroJuego jugadorActual.aux2 := jugadorDesafiado.self controlDeTiempos .self crearMorphTimmer: 10 timmer2: 10.self crearMorphsPuntos.self crearMorphimagen.! !!DueloMC methodsFor: 'manage duelos' stamp: '2/16/2025 23:44'!iniciarDueloDeluxeEnJuego:unJuego conTema: unTema 	| jugadorDesafiado fila columna cantidadJugadores tablero|	self punteroJuego: unJuego.	tablero:= self punteroJuego tableroLogico.	fila := 1.	columna := 1.	cantidadJugadores:= unJuego cantJugadores.	self temaDuelo: unTema.		1 to: cantidadJugadores do: [ :index | 		"Iteramos sobre la matriz TableroLogico"		(fila > cantidadJugadores sqrt ceiling) ifTrue: [ 			fila := 1. 			columna := columna + 1 			].		(((tablero matrizTableroLógico at: fila column: columna) tema) = (self temaDuelo)) ifTrue: [ 			jugadorDesafiado := (tablero matrizTableroLógico at: fila column: columna)			].		fila := fila + 1.		].self initializeDeluxe.self jugadorActual: true.self dibujarDuelo.self crearMorphNombres: (punteroJuego jugadorActual nombre asString) desafiadoNombre: jugadorDesafiado nombre asString. aux1 := punteroJuego jugadorActual.aux2 := jugadorDesafiado.self controlDeTiempos .self crearMorphTimmer: 10 timmer2: 10.self crearMorphsPuntos.self crearMorphimagen.! !!DueloMC methodsFor: 'ManageJuego' stamp: '2/16/2025 23:19'!ganaDesafiante: arg1 desafiado: arg2	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 fila columna |	tmp4 := self punteroJuego cantJugadores sqrt ceiling.	tmp5 := self punteroJuego cantJugadores sqrt ceiling.	tmp1 := 1.	tmp2 := 1.	tmp3 := nil.	tmp6 := self punteroJuego cantJugadores.	tmp7 := tmp6.	tmp8 := tmp7.	1 to: tmp8 do: [ :tmp9 |		(self punteroJuego tableroLogico matrizDeMorphs at: tmp1 column: tmp2) tema		= arg1 tema ifTrue: [			tmp3 := self punteroJuego tableroLogico matrizDeMorphs at: tmp1 column: tmp2 ].		tmp1 := tmp1 + 1.		tmp1 > tmp4 ifTrue: [			tmp1 := 1.			tmp2 := tmp2 + 1 ] ].	1.	tmp1 := 1.	tmp2 := 1.	tmp6 := self punteroJuego cantJugadores.	tmp7 := tmp6.	tmp8 := tmp7.	1 to: tmp8 do: [ :tmp9 |		tmp1 > tmp4 ifTrue: [			tmp1 := 1.			tmp2 := tmp2 + 1 ].		(self punteroJuego tableroLogico matrizDeTemas at: tmp1 column: tmp2) = arg2 tema			ifTrue: [				self punteroJuego tableroLogico matrizDeTemas at: tmp1 column: tmp2 put: arg1 tema.				(self punteroJuego tableroLogico matrizDeMorphs at: tmp1 column: tmp2) tema				= arg2 tema ifTrue: [					(self punteroJuego tableroLogico matrizDeMorphs at: tmp1 column: tmp2) tema:						arg1 tema.					(self punteroJuego tableroLogico matrizDeMorphs at: tmp1 column: tmp2) morph						color: tmp3 morph color.					(self punteroJuego tableroLogico matrizDeMorphs at: tmp1 column: tmp2) labelMorph						contents: arg1 tema ] ].		tmp1 := tmp1 + 1.		tmp1 > tmp4 ifTrue: [			tmp1 := 1.			tmp2 := tmp2 + 1 ] ].	1.	UIManager default inform:		'Ganó: ' , arg1 nombre , ' ' , 'tema: ' , arg1 tema.	fila := 1.	columna := 1.	1 to: self punteroJuego cantJugadores do: [ :i |		(fila > self punteroJuego cantJugadores sqrt ceiling) ifTrue: [ fila := 1. columna := columna + 1 ].		((self punteroJuego tableroLogico matrizTableroLógico at: fila column: columna) nombre = arg2 nombre) ifTrue: [			self punteroJuego tableroLogico matrizTableroLógico at: fila column: columna put: arg1		].		fila := fila + 1.	].! !Object subclass: #Jugador	instanceVariableNames: 'nombre tema puntosProbabilidad'	classVariableNames: ''	package: 'TheConquist'!!Jugador methodsFor: 'accessing' stamp: '2/16/2025 22:20'!nombre	^ nombre! !!Jugador methodsFor: 'accessing' stamp: '2/16/2025 22:20'!nombre: anObject	nombre := anObject! !!Jugador methodsFor: 'accessing' stamp: '2/16/2025 22:20'!tema	^ tema! !!Jugador methodsFor: 'accessing' stamp: '2/16/2025 22:20'!tema: anObject	tema := anObject! !!Jugador methodsFor: 'accessing' stamp: '2/16/2025 22:20'!puntosProbabilidad	^ puntosProbabilidad! !!Jugador methodsFor: 'accessing' stamp: '2/16/2025 22:20'!puntosProbabilidad: anObject	puntosProbabilidad := anObject! !!Jugador methodsFor: 'initialize' stamp: '2/7/2025 15:10'!initializeself puntosProbabilidad: 0.! !